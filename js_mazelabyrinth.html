<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Maze Game WebGL with Bot Mode & Map Overlay</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* WebGL canvas fills the viewport */
    #glCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    /* Overlay canvas for 2D map and help text */
    #mazeCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: auto;
    }
  </style>
  <script src="gl-matrix-min.js"></script>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  <canvas id="mazeCanvas"></canvas>
  <script>
    // ============================ Utility Functions ============================
    function toRadian(deg) {
      return deg * Math.PI / 180;
    }
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    function lerpAngle(a, b, t) {
      return a + (b - a) * t;
    }

    // ============================ Shader Sources ============================
    const vsSource = `
      attribute vec3 aPosition;
      attribute vec2 aTexCoord;
      uniform mat4 uProjection;
      uniform mat4 uView;
      uniform mat4 uModel;
      varying vec2 vTexCoord;
      void main(void) {
          gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
          vTexCoord = aTexCoord;
      }
    `;
    const fsSource = `
      precision mediump float;
      varying vec2 vTexCoord;
      uniform sampler2D uTexture;
      void main(void) {
          gl_FragColor = texture2D(uTexture, vTexCoord);
      }
    `;

    // ============================ Shader Utility Functions ============================
    function loadShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Error linking shader program: " + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    }

    // ============================ Texture Loader ============================
    function loadTexture(gl, url) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      // Temporary 1x1 pixel (white) until image loads.
      const level = 0, internalFormat = gl.RGB, width = 1, height = 1, border = 0,
            srcFormat = gl.RGB, srcType = gl.UNSIGNED_BYTE;
      const pixel = new Uint8Array([255, 255, 255]);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height,
                    border, srcFormat, srcType, pixel);
      const image = new Image();
      image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                      srcFormat, srcType, image);
        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
          gl.generateMipmap(gl.TEXTURE_2D);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
      };
      image.onerror = function() {
        console.error("Failed to load texture: " + url);
      };
      image.src = url;
      return texture;
    }
    function isPowerOf2(value) {
      return (value & (value - 1)) === 0;
    }

    // ============================ Maze Generation Code ============================
    class Rect {
      constructor(x, y, w, h) {
        this.x1 = x;
        this.y1 = y;
        this.x2 = x + w;
        this.y2 = y + h;
        this.center = [Math.floor((this.x1 + this.x2) / 2), Math.floor((this.y1 + this.y2) / 2)];
      }
      intersect(other) {
        return (this.x1 < other.x2 && this.x2 > other.x1 &&
                this.y1 < other.y2 && this.y2 > other.y1);
      }
    }
    function createMap(width, height, maxRooms, roomMinSize, roomMaxSize, seed) {
      if (seed !== undefined) console.log("Creating map with seed:", seed);
      let mapGrid = Array.from({ length: height }, () => Array.from({ length: width }, () => '#'));
      let rooms = [];
      for (let r = 0; r < maxRooms; r++) {
        let w = Math.floor(Math.random() * (roomMaxSize - roomMinSize + 1)) + roomMinSize;
        let h = Math.floor(Math.random() * (roomMaxSize - roomMinSize + 1)) + roomMinSize;
        let x = Math.floor(Math.random() * (width - w - 2)) + 1;
        let y = Math.floor(Math.random() * (height - h - 2)) + 1;
        let newRoom = new Rect(x, y, w, h);
        if (rooms.some(room => newRoom.intersect(room))) continue;
        for (let i = newRoom.y1 + (w>2&&h>2?1:0); i < newRoom.y2 - (w>2&&h>2?1:0); i++) {
          for (let j = newRoom.x1 + (w>2&&h>2?1:0); j < newRoom.x2 - (w>2&&h>2?1:0); j++) {
            mapGrid[i][j] = ' ';
          }
        }
        if (rooms.length > 0) {
          let prev = rooms[rooms.length - 1];
          let [prevX, prevY] = prev.center;
          let [newX, newY] = newRoom.center;
          if (Math.random() < 0.5) {
            for (let xCorr = Math.min(prevX, newX); xCorr <= Math.max(prevX, newX); xCorr++) mapGrid[prevY][xCorr] = ' ';
            for (let yCorr = Math.min(prevY, newY); yCorr <= Math.max(prevY, newY); yCorr++) mapGrid[yCorr][newX] = ' ';
          } else {
            for (let yCorr = Math.min(prevY, newY); yCorr <= Math.max(prevY, newY); yCorr++) mapGrid[yCorr][prevX] = ' ';
            for (let xCorr = Math.min(prevX, newX); xCorr <= Math.max(prevX, newY); xCorr++) mapGrid[newY][xCorr] = ' ';
          }
        }
        rooms.push(newRoom);
      }
      if (rooms.length > 0) {
        let lastRoom = rooms[rooms.length - 1];
        let center = lastRoom.center;
        let candidates = [];
        if (lastRoom.x2-lastRoom.x1>=6 && lastRoom.y2-lastRoom.y1>=6) {
          candidates = [
            [lastRoom.x1+1, lastRoom.y1+1],
            [lastRoom.x2-2, lastRoom.y1+1],
            [lastRoom.x1+1, lastRoom.y2-2],
            [lastRoom.x2-2, lastRoom.y2-2]
          ];
        } else {
          for (let y = lastRoom.y1+1; y < lastRoom.y2-1; y++) {
            candidates.push([lastRoom.x1+1, y]);
            candidates.push([lastRoom.x2-2, y]);
          }
        }
        let exit = candidates.reduce((best, c) => {
          let d = Math.abs(c[0]-center[0])+Math.abs(c[1]-center[1]);
          return d>(best.d||-1)?{c,d}:{best};
        }, {}).c;
        if (exit) mapGrid[exit[1]][exit[0]]='E';
      }
      for (let i=0;i<height;i++) for (let j=0;j<width;j++) {
        if (mapGrid[i][j]==='#') {
          let roomCorner=false;
          for (let room of rooms) for (let c of [[room.x1,room.y1],[room.x2-1,room.y1],[room.x1,room.y2-1],[room.x2-1,room.y2-1]]) {
            if (c[0]===j&&c[1]===i) roomCorner=true;
          }
          if (roomCorner) continue;
          let adjOpen=false;
          for (let d of [[-1,0],[1,0],[0,-1],[0,1]]) {
            let nx=j+d[0], ny=i+d[1];
            if (nx>=0&&nx<width&&ny>=0&&ny<height) {
              if (mapGrid[ny][nx]===' '||mapGrid[ny][nx]==='E') adjOpen=true;
            }
          }
          if (!adjOpen) mapGrid[i][j]='B';
        }
      }
      return { maze: mapGrid.map(r=>r.join('')), rooms };
    }

    // ============================ Build Maze Geometry ============================
    function buildMazeGeometry(maze) {
      let floorVerts = [], ceilingVerts = [], wallBrickVerts = [], wallExitVerts = [];
      const rows = maze.length, cols=maze[0].length;
      for (let z=0;z<rows;z++) for (let x=0;x<cols;x++) {
        // floor & ceiling
        [[floorVerts,0],[ceilingVerts,1]].forEach(([arr,y])=>{
          arr.push(x,y,z,0,0, x+1,y,z,1,0, x+1,y,z+1,1,1, x,y,z,0,0, x+1,y,z+1,1,1, x,y,z+1,0,1);
        });
        let cell=maze[z][x]; if (['#','B','E'].includes(cell)) {
          let isExit = cell==='E';
          [['north',z===0||!['#','B','E'].includes(maze[z-1][x])],[
           'south',z===rows-1||!['#','B','E'].includes(maze[z+1][x])],[
           'west',x===0||!['#','B','E'].includes(maze[z][x-1])],[
           'east',x===cols-1||!['#','B','E'].includes(maze[z][x+1])]
          ].forEach(([dir,cond])=>{
            if (!cond) return;
            let target = isExit? wallExitVerts: wallBrickVerts;
            if (dir==='north') target.push(x,0,z,0,0, x+1,0,z,1,0, x+1,1,z,1,1, x,0,z,0,0, x+1,1,z,1,1, x,1,z,0,1);
            if (dir==='south') target.push(x,0,z+1,0,0, x+1,0,z+1,1,0, x+1,1,z+1,1,1, x,0,z+1,0,0, x+1,1,z+1,1,1, x,1,z+1,0,1);
            if (dir==='west')  target.push(x,0,z,0,0, x,0,z+1,1,0, x,1,z+1,1,1, x,0,z,0,0, x,1,z+1,1,1, x,1,z,0,1);
            if (dir==='east')  target.push(x+1,0,z,0,0, x+1,0,z+1,1,0, x+1,1,z+1,1,1, x+1,0,z,0,0, x+1,1,z+1,1,1, x+1,1,z,0,1);
          });
        }
      }
      return { floor: new Float32Array(floorVerts), ceiling: new Float32Array(ceilingVerts), wallBrick: new Float32Array(wallBrickVerts), wallExit: new Float32Array(wallExitVerts) };
    }

    // ============================ Global Variables ============================
    let gl, shaderProgram;
    let attribLocations, uniformLocations;
    let buffers = {};
    let textures = {};
    let mazeData, geometry;
    let discovered = [];
    let playerPos = [2.5, 0.0, 2.5];
    let playerAngle = 0;
    const mazeWidth = 100, mazeHeight = 100, maxRooms = 40, roomMinSize = 3, roomMaxSize = 8;
    let fullMapVisible = false;
    let helpVisible = true;  // show help overlay on load

    // (rest of bot mode, pathfinding, movement, rendering, overlay code unchanged...)
    // …

    window.onload = init;
  </script>
</body>
</html>

